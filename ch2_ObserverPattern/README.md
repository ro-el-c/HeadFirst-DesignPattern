# 옵저버 패턴 (Observer Pattern)

### ch2 옵저버 패턴

자세한 정리는 [Tistory](https://roel-yomojomo.tistory.com/entry/HeadFirst-observer-pattern)에 게시하였습니다.

<br>

## 옵저버 패턴 (Observer Pattern)

> 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다(one-to-many) 의존성을 정의하는 디자인 패턴

<br>

### 신문사와 구독자, 주제와 옵저버

신문사는 구독 중인 모든 독자에게 신문을 제공한다.

옵저버 패턴에서 신문사는 ‘**주제(Subject)**’에 해당하고 구독자는 ‘**옵저버(Observer)**’에 해당하며 **일대다 관계**가 정의된다.

옵저버는 주제에 등록되며, 주제의 상태가 바뀌면 옵저버에게 정보가 전달된다.

<br>

## 옵저버 패턴의 구조

Subject 인터페이스와 Observer 인터페이스가 들어있는 클래스 디자인으로 구현된다.

구상 클래스가 각각의 인터페이스를 구현하며, Subject 객체는 List로 Observer 객체를 담고 있다.

<br>

### 주제 (Subject)

**인터페이스**

객체에서 옵저버로 등록하거나 옵저버 목록에서 탈퇴하고 싶을 때 사용하는 메서드가 담겨 있다.

객체에서 옵저버로 등록할 때 Subject의 List에 추가되며, 탈퇴할 때는 삭제된다.

**구상 클래스**

Subject 인터페이스를 구현한다. 상태가 바뀔 때 모든 옵저버에게 연락하는 notifyObservers 메서드를 구현해야 한다.

<br>

### 옵저버 (Observer)

**인터페이스**

주제의 상태가 바뀌었을 때 호출되는 update 메서드만 존재한다.

**구상 클래스**

Observer 인터페이스를 구현한다. 각 옵저버는 특정 주제에 등록하여 연락을 받을 수 있다.

<br>

---
## 디자인 원칙

### 네 번째, 느슨한 결합

> 상호작용하는 객체 사이에는 가능하면 **느슨한 결합**을 사용해야 한다.

<br>


느슨하게 결합하는 디자인을 사용하면 객체 사이의 상호의존성을 최소화할 수 있기 때문에, 변경 사항이 생겨도 무난히 처리할 수 있는 **유연**한 객체지향 시스템을 구축할 수 있다.

옵저버 패턴은 느슨한 결합을 잘 보여주는 예이다.

<br>

### 옵저버 패턴에 적용된 디자인 원칙

1. 첫 번째, 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.
   - 주제의 상태와 무관하게 옵저버의 개수와 형식을 바꿀 수 있다.
2. 두 번째, 구현보다는 인터페이스에 맞춰서 프로그래밍한다.
   - 주제와 옵저버 모두 인터페이스를 사용했다. 이를 통해 느슨한 결합를 만들 수 있다.
3. 세 번째, 상속보다는 구성을 활용한다.
   - 구성을 활용하여 옵저버들을 관리한다. 주제 ↔ 옵저버 : 구성

위에서 언급된 세 가지 디자인 원칙에 대한 설명은 [전략 패턴과 세 가지 디자인 원칙](https://roel-yomojomo.tistory.com/entry/HeadFirst-strategy-pattern#%EB%94%94%EC%9E%90%EC%9D%B8%20%EC%9B%90%EC%B9%99-1) 포스트를 통해 확인할 수 있습니다.

<br>

## 느슨한 결합 (Loose Coupling)

객체들이 상호작용할 수 있지만, 서로를 잘 모르는 관계를 의미한다.

<br>

### 옵저버 패턴이 느슨한 결합을 만드는 방식

1. **주제는 옵저버가 특정 인터페이스를 구현한다는 사실만 안다.**
2. 옵저버는 언제든지 새로 추가할 수 있다.
   - 다형성
3. 새로운 형식의 옵저버를 추가할 때도 주제를 변경할 필요가 없다.
4. 주제와 옵저버는 서로 독립적으로 재사용할 수 있다.
5. 주제나 옵저버가 달라져도 서로에게 영향을 미치지 않는다.

이 다섯 가지 방식으로 인하여 Subject와 Observer 사이의 결합은 **느슨한 결합**이다.

<br>

---
## Think About

Subject가 자신이 가지고 있는 모든 데이터를 Observer에게 직접 전달하는 것이 상태를 갱신하는 가장 간단한 방법일까?

갱신된 상태를 옵저버에게 전달하는 문제를 해결할 수 있는 다른 접근법을 생각해 보자.

<br>

### Data Push vs Pull

**Push**: Subject가 Observer에게 상태를 알리는 방식 - 자신이 알고 있는 모든 데이터를 보낸다.

**Pull**: Observer가 Subject로부터 상태를 가져오는 방식 - 자신이 필요한 데이터만 가져온다.

<br>

Subject가 자신이 가지고 있는 모든 데이터를 Observer에게 전달(push)하면, Observer는 불필요한 데이터도 전달 받게 된다.

또, Subject는 자신이 가지는 데이터가 확장되면 갱신하는 메서드도 일일이 고쳐야 한다.

<br>

### 더 옳은 방식, Data Pull

이렇게 구현했을 때, 수많은 Observer 구현체가 필요로 하는 데이터의 종류가 모두 다르다면 어떨까?

Subject가 모든 데이터를 push하는 것보다, Observer가 자신이 **필요한 데이터만 가져오는 것**(**pull**)이 더 좋을 것이다.

<br>

이 방법을 구현하는 것은 어렵지 않다.

Subject에 데이터에 관한 getter 메서드를 만들고, Observer에서는 필요한 데이터를 pull할 때 해당 메서드를 호출하면 된다.