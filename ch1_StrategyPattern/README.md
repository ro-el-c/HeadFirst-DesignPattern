# 전략 패턴 (Strategy Pattern)

### ch1 디자인 패턴 소개와 전략 패턴

자세한 정리는 [Tistory](https://roel-yomojomo.tistory.com/entry/HeadFirst-strategy-pattern)에 게시하였습니다.

<br>

## 전략 패턴 (Strategy Pattern)

> 알고리즘군을 정의하고 캡슐화하여, 실행 중에 알고리즘을 교체할 수 있게 하는 디자인 패턴

<br>

**변경 가능성이 있는 부분을 분리**하여 **인터페이스**를 이용하여 **캡슐화**하고, 실행 중에 **구현체를 선택하여 사용**할 수 있도록 한다.
<br><br><br>

---

## 디자인 원칙

### 첫 번째, 캡슐화

> 애플리케이션에서 **달라지는 부분**을 찾아내고, 달라지지 않는 부분과 **분리**한다.

<br>

달라지는 부분을 찾아서, 나머지 부분에 영향을 주지 않도록 ‘**캡슐화**’한다.

그렇게 하면 서로 다른 형식의 객체에서 사용할 수 있다는 점에서 ‘**재사용성**’이 증가하며, 나중에 바뀌지 않는 부분에는 영향을 미치지 않고 그 부분만 고치거나 '**확장**'할 수 있다.

<br>

***모든 디자인 패턴의 기반을 이루는 원칙이다.***

why?

‘시스템의 일부분을 다른 부분과 독립적으로 변화시킬 수 있는’ 방법을 제공하기 때문이다.


<br>

### 두 번째, 다형성

> 구현보다는 **인터페이스에 맞춰서** 프로그래밍한다.

<br>

실제 실행 시에 쓰이는 객체가 코드에 고정되지 않도록 상위 형식(supertype)에 맞춰서 프로그래밍하여 ‘**다형성**’을 활용한다.

- **변수를 선언**할 때, **추상 클래스 혹은 인터페이스 같은 상위 형식으로 선언**한다.
- 객체를 변수에 대입할 때 상위 형식을 구체적으로 구현한 형식이라면 어떤 객체든 넣을 수 있다.
- 변수를 선언하는 클래스에서 실제 객체의 형식을 몰라도 된다.

<br>

### 세 번째, 구성

> 상속보다는 **구성**(**composition**)을 활용한다. = “A에는 B가 있다.”

<br>

구성으로 사용하는 객체를 확장하면(올바른 인터페이스를 구현하면), 실행 중에 **동적으로 설정**할 수 있게 되어 시스템의 유연성이 크게 향상된다.

→ 새로운 코드를 만들어 기능을 추가할 수 있다.
<br><br><br>

---

## 장단점

### 장점

기존 코드의 변경 없이 새로운 전략을 추가 및 수정할 수 있어 매우 유연하다.

→ OCP 원칙을 지킬 수 있다.

<br>

### 단점

코드의 복잡도가 증가하며, 모든 전략 간의 차이를 알고 있어야 한다.

알고리즘이 단순하고 다양하지 않다면, 코드만 복잡해질 수 있다.
